## Retrospective Post-mortem Document  

### Evan  
#### What I learned:  
  The majority of my learning came was with development operations, specifically continuous development / integration, testing, docker, and deployment. A goal for myself for the class was to learn how to use various new technologies, it would be an understatement to say this was the case. I ended up using travis for the CD/CI work and got well attuned with it, learning how it uses stages to build, test, and deploy the application, as well as how to configure the pipeline to our needs and specifications. Even though it ended up being optional, I did learn how to use docker and how it would be applicable with our app. I created a Dockerfile for our app, and got travis to build and deploy a new docker image at the end of every successful pipeline. As far as software architecture is concerned, I got to know our design inside and out as I helped to reshape our codebase to better fit the MVC architecture as we envisioned it. TSLint complimented this process as I linted most of the app, and got to see how different models and controllers worked together. I also got the chance to learn about how node works (mainly npm), did some dependency work, unit testing (via mocha), code coverage (via istanbul’s nyc), and how to run CRON jobs.

#### What I could’ve been done better:  
  I should have been more involved in the process of implementing the user stories, instead of focusing on the background functionality, as sometimes the group members all had different ideas on how the user story would be implemented, and we would fail to have a proper discussion about it until afterwards. I could have also been better at communicating what exactly it was that I was doing. Because a lot of my work went into background processes and dev op stuff, it couldn’t have been all that apparent to my group members what was going on. This is furthered by the fact that you could not see a lot of the results I was getting, only that they worked as expected (testing suite, pipeline). 


### How our design could have been improved:  
#### Misuse of mongodb connections:  
  Originally throughout our code milestone, we created a new connection to the mongodb whenever a route was called, sometimes creating several at once depending on the functionality used. This design flaw was only discovered late in the project when we needed to have the database concurrently updating as it was being used. We found that updating the database every 2 minutes ate up all the possible mongodb connections very quickly. We were able to find a last minute fix that solved the problem quite well. Instead of using a new connection for each route and model method we would use a global variable that was what connected to the database. In this way we could localise connections to their respective models and controllers, thereby minimizing the existing connections a user might have. However, because the solution was found last minute we were unable to make this fix for the entire application, but rather only for the CRON jobs that needed regular access to the database. In this way, we acknowledge that we can improve the performance of the application overall by redesigning how we connect to the database through the localization of connections.
